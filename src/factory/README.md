# 工厂方法模式（Factory Method Pattern）

### 概念
定义了一个创建对象的接口，但由子类决定要实例化的类是哪一个。工厂方法让类把实例化推迟到子类。

### 结构
- `pizza`包：定义了产品（Product）类，即具体有哪些产品类型。
- `store`包：定义了创建者（Creator）类，即通过工厂方法创建对象。
- `order`包：测试。

产品类与创建者类位于同一层级，即它们都有抽象类，而其具有多种具体的子类实现。

具有如下定义：`abstract Product factroyMethod(String type)`。
- `abstract`表明工厂方法是抽象的，依赖子类来处理对象的创建；
- `Product`类型表明工厂方法必须返回一个产品，在超类中定义的方法，通常使用工厂方法的返回值；
- 对于`factoryMehtod`即工厂方法实现来说，将客户和实际创建产品的代码分隔开来。

工厂方法模式中使用了**依赖倒置原则**：
- 变量不可以持有具体类的引用；
- 不要让类派生自具体类；
- 不要覆盖基类中已实现的方法。

# 抽象工厂模式（Abstract Factory Pattern）
### 概念
提供一个接口，用于创建相关或依赖对象的家族，而不需要明确指定具体类。

### 结构
重构了`factory`包下的结构：
- `ingredient`包：提供原料具体类型，每种具体原料是其原料接口的实现。
- `factory`包：定义了生成原料的方法。其中，`PizzaIngredientFactory`是工厂方法的实现，其定义了创建对象的接口，但由子类决定要实例化的是哪个类。
- `pizza`包：被重构。其中`Pizza`抽象类定义了比萨所含有的原料，并暴露出`prepare()`方法由子类具体实现；子类中，通过**组合**的形式将原料工厂组合进来，并由工厂负责生产制造比萨的原料，其中，比萨的原料类型由传入的工厂对象类型决定，解耦了比萨类型与不同的城市比萨类型。
- `store`包：被重构。其中`PizzaStore`抽象类没有被改变，其子类实现中将具体的原料工厂组合进来，并由具体的原料工厂装配具有城市特色的比萨类型。
- `order`包：测试抽象工厂模式。

# 简单工厂、工厂方法、抽象工厂
- 简单工厂如`store`包中的`createPizza()`方法，通过传入的参数类型，用判断语句创建不同的对象。
- 工厂方法即，一个方法对应创建一种对象。创建每一种对象都由其实现了工厂方法接口来定义，如上一个提交中的`NYStyleStore`与`ChicagoStyleStore`即为创建`NYStyleCheesePizza`和`ChicagoStyleCheesePizza`的工厂方法，一个工厂对应了一种对象类型，其创建出的对象类型拥有共同的父类。
- 抽象工厂，如`factory`包中的`PizzaIngredientFactory`，组合了一组具有同类型的产品家族，每个子类使用自己区域的供货商实现自己的原料。